#*
## Name: 
## Desc: 
## Inputs:
## Usage:
function gcaa () {(
    git add . && git commit -m "$*" && git push
    )}
#*

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
dfca() {
    dotfiles add -u && dotfiles commit -m "$*" && dotfiles push 
}
#* *
## Name: 
## Desc: 
## Inputs:
## Usage:
og() {(
    set -e
    git remote -v | grep push
    remote=${1:-origin}
    echo "Using remote $remote"
    URL=$(git config remote.$remote.url | sed "s/git@\(.*\):\(.*\).git/https:\/\/\1\/\2/")
    echo "Opening $URL..."
    open $URL
)}
#*

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
nr() {
  mkdir "$*"
  cd "$*"
}
#*  

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
resizejpg() {
    for i in *.jpg; 
        do name=`echo $i | cut -d'.' -f1`;
        echo $name;
        convert $i -resize "$*"% $name.jpg;
    done
}
#*
#*
## Name: 
#
## Desc: 
## Inputs:
## Usage:
htj() {
    heif-convert -q 75 $1.heic $2.jpg
}
#*

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
convmp4() {
    for i in *.mp4; 
        do name=`echo $i | cut -d'.' -f1`;
        echo $name;
        ffmpeg -c:v h264_cuvid -i $i -c:v dnxhd -profile:v dnxhr_hq -pix_fmt yuv422p -c:a pcm_s16le $name.mov;
    done
}
#*

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
qgcd() {
    cd ~/Git/Quasar
    git clone $1
    local ldir=`ls -snew | head -1`
    echo $ldir
    cd $ldir
    pwd
    yarn
    qd
}
#*
#
gcnn() {
    cd ~/Git/Webdev/Nuxt
    git clone git@github.com:Thevetat/SignalAIBaseLayer.git "$*"
    cd "$*"
    rm -r -f .git
    git init
    pnpm i
}


#*
## Name: Git Clone Quasar Base
## Desc: Clones base quasar repo, cd's in, opens code, runs yarn, opens dev server
## Inputs: Name you want to call new folder
## Usage: gcqb playground
gcqb() {
    cd ~/Git/Quasar
    git clone --single-branch --branch electron git@gitlab.com:Paracelsus_Rose/vitebase.git "$*"
    cd "$*"
    rm -r -f .git
    git init
    yarn
    qd
}
#*

#*
## Change Docs
## Name: Git Clone Typescript Base
## Desc: Clones base quasar repo, cd's in, opens code, runs yarn, opens dev server
## Inputs: Name you want to call new folder
## Usage: gcqb playground
gctb() {
    cd ~/Git/Typescript
    git clone git@gitlab.com:sunshineunlimited/ts-base-reborn.git "$*"
    cd "$*"
    rm -r -f .git
    git init
    pnpm i
}
#*


#*
## Change Docs
## Name: Git Clone Typescript Base
## Desc: Clones base quasar repo, cd's in, opens code, runs yarn, opens dev server
## Inputs: Name you want to call new folder
## Usage: gcqb playground
gcnbub() {
    cd ~/Git/Go/tui/
    git clone git@github.com:Thevetat/new_bubble.git "$*"
    cd "$*"
    rm -r -f .git
    git init
}
#*

#*
## Change Docs
## Name: Git Clone Typescript Base
## Desc: Clones base quasar repo, cd's in, opens code, runs yarn, opens dev server
## Inputs: Name you want to call new folder
## Usage: gcqb playground
gcvb() {
    cd ~/Git/Vite
    git clone git@gitlab.com:sunshineunlimited/sunshine-base.git "$*"
    cd "$*"
    rm -r -f .git
    git init
    pnpm i
}
#*

gsubi() {
    git submodule update --init --recursive
}

gsuba() {
    git submodule add git@github.com:Thevetat/ComponentSubmodule.git base_components
}

gsubar() {
    git submodule add git@github.com:Thevetat/BaseReactSubmod.git ./src/base_submod
}

gsubp() {
z base_components
git add .
git commit -m "Updated Component Submodule"
git push
z ../
}

gsubu() {
z base_components
git pull
z ../
}

#*
## Change Docs
## Name: Git Clone New Base
## Desc: Clones base quasar repo, cd's in, opens code, runs yarn, opens dev server
## Inputs: Name you want to call new folder
## Usage: gcqb playground
gcnb() {
    cd ~/Git/Vite
    git clone git@gitlab.com:sunshineunlimited/nbase.git "$*"
    cd "$*"
    rm -r -f .git
    git init
    pnpm i
}
#*


#*
## Change Docs
## Name: Git Clone Typescript Base
## Desc: Clones base quasar repo, cd's in, opens code, runs yarn, opens dev server
## Inputs: Name you want to call new folder
## Usage: gcqb playground
gceb() {
    cd ~/Git/Quasar
    git clone --single-branch --branch electron git@gitlab.com:Paracelsus_Rose/vitebase.git "$*"
    cd "$*"
    rm -r -f .git
    git init
    yarn
}
#*


#*
## Name: Find
## Desc: Find a file matching the input
## Inputs: Pattern you want to search for
## Usage: f .json
f() {
    find . | grep -i "$*"
}
#*


#*
## Name: 
## Desc: 
## Inputs:
## Usage:
gpar() {
    find . -type d -name .git -exec git --git-dir={} --work-tree=$PWD/{}/.. pull origin master
}
#*

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
m() {
    mkdir "$*"
}
#*

#*
## Name: 
## Desc: 
## Inputs:
## Usage:
newssh() {
yes "y" | ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/"$*" -N ""
cat ~/.ssh/"$*".pub | xsel --clipboard
}
#*


#*
## Name: 
## Desc: 
## Inputs:
## Usage:
cf() {
    xsel -b < "$*"
}
#*



#*
## Name: 
## Desc: 
## Inputs:
## Usage:
freshnvim() {
    mkdir ~/.config/.nvim_backup
    mkdir ~/.config/.nvim_backup/.local/share/nvim
    mkdir ~/.config/.nvim_backup/.cache/nvim
    cp -r -f ~/.config/nvim ~/.config/.nvim_backup/
    cp -r -f ~/.local/share/nvim ~/.config/.nvim_backup/.local/share/nvim
    cp -r -f ~/.cache/nvim ~/.config/.nvim_backup/.cache/nvim
    rm -rf ~/.config/nvim
    rm -rf ~/.local/share/nvim 
    rm -rf ~/.cache/nvim
}
#*


ipynb() {
    python -m jupyter_ascending.scripts.make_pair --base "$*"
}

yad() {
    yarn add "$*" --dev
}

ya() {
    yarn add "$*"
}

cw() {
    cd "$(which "$*" | xargs -0 dirname)"
}

# #*
# ## Name: 
# ## Desc: 
# ## Inputs:
# ## Usage:
# gcd() {
#     cd ~/Git/External
#     git clone "$*"
#     cd "$*"
#     ls -a
#     nvim
# }
# #*
# #

gcd() {
    cd ~/Git/External
    if [ -z $1 ]
    then
        echo "Error: No repository URL provided"
        return 1
    fi

    repo_name=$(echo $1 | sed -E 's#(https://(github|gitlab)\.com/)([^/]+/[^/]+)/?#\3#' | cut -d '/' -f 2)

    git clone $1

    if [ $? -eq 0 ]
    then
        cd "$repo_name"
        echo "Successfully cloned and entered repository: $repo_name"
    else
        echo "Error: Repository not cloned"
        return 1
    fi
    ls -a 
}

fd2() {
    curl -fsSL https://d2lang.com/install.sh | sh -s -- --uninstall
    rm -r -f $HOME/.local/bin/d2
    rm -r -f $HOME/.local/lib/d2
    rm -r -f $HOME/Git/External/d2/
    curl -fsSL https://d2lang.com/install.sh | sh -s -- --tala
    rm -r -f $HOME/.local/bin/d2
    rm -r -f $HOME/.local/lib/d2
    gcd git@github.com:terrastruct/d2
    ./ci/release/build.sh --install
    d2 -v
    d2 layout tala
    
}

d2r() {
    D2_LAYOUT=tala d2 --watch --sketch "$*".d2 "$*".svg
}

rcd2() {
    rm -r -f ci/release/build/$1
    d2c
}

cng() {
    git init --initial-branch=main
    git remote add origin $1
    git add .
    git commit -m "Initial commit"
    git push -u origin main
}

shopliftdev() {
    PORT=3000 HOST=https://7524-104-128-161-112.ngrok.io/ dotnet run watch
}

switchnvim() {
    mv ~/.config/nvim ~/.config/nvim_old
    mv ~/.config/nvimA ~/.config/nvim
    mv ~/.config/nvim_old ~/.config/nvimA

    mv ~/.local/share/nvim ~/.local/share/nvim_old
    mv ~/.local/share/nvimA ~/.local/share/nvim
    mv ~/.local/share/nvim_old ~/.local/share/nvimA
}

ndc() {
    rm -r -f ./docs/$1
    mkdir ./docs/$1
    depcruise --include-only "^src" -x "^src/store" -v -T dot src | dot -T svg | depcruise-wrap-stream-in-html > ./docs/$1/dep-graph-reduced.html
    depcruise -v -T dot | dot -T svg | depcruise-wrap-stream-in-html > ./docs/$1/dep-graph-full.html
    depcruise src --output-type dot | dot -T svg > ./docs/$1/dep-graph-full.svg
    dependency-cruise --validate --output-type err-html -f ./docs/$1/dep-report.html src 
    depcruise src --include-only "^src" --config --output-type json > ./docs/$1/dep-graph-full.json
    depcruise src --include-only "^src" --config --output-type archi | dot -T svg > ./docs/$1/dep-graph-archi.svg
}

genDepPics() {
    dep_full="./dep_docs/full/pics"
    dep_collapsed="./dep_docs/collapsed/pics"

    rm -r -f $dep_full
    rm -r -f $dep_collapsed

}

ubcomp() {
  cd src/core/components/base
  git pull
  git add .
  git commit -m "update bcomp"
  git push
  cd ../../../../
}



preupscale() {
  input_file=$1
  preup_file="${input_file%.*}.mp4"

  # Copy the preupscaled file to the pre-upscale folder
  destination_folder="pre-upscale"

  if [[ ! -d $destination_folder ]]; then
    mkdir $destination_folder
  fi

  cp "$preup_file" "$destination_folder"
}

preup() {
  find . -type f -name '*.mp4' -print0 | while read -d '' -r file; do
    preupscale "$file"
  done
}

#*
## Name: ConvertAndDelete
## Desc: Find all PNG files, convert them to WEBP and then delete the original PNG files
## Inputs: None
## Usage: ConvertAndDelete
pngtowebp() {
    find . -type f -name "*.png" -print0 | while IFS= read -r -d '' file; do
        local webp_file="${file%.png}.webp"
        convert "$file" "$webp_file" && rm -f "$file"
    done
}
#*
#

initgo() {
    go mod init github.com/thevetat/"$*"
}

pnr() {
    git init --initial-branch=main
    git remote add origin "$*"
    git add .
    git commit -m "Initial commit"
    git push --set-upstream origin main
}

dlsc() {
   scdl -l "$*" --addtofile --onlymp3 --no-playlist-folder --extract-artist -c
}

newnuxt() {
    pnpm dlx nuxi@latest init "$*"
}


nd() {
    netlify unlink
    netlify sites:delete "$*" --force
}

gsr() {
    if [ $# -lt 2 ]; then
        echo "Usage: gsr <commit-hash> <commit-message>"
        return 1
    fi
    
    local commit_hash="$1"
    shift
    local commit_message="$*"
    
    git reset --soft "$commit_hash" && \
    git commit -m "$commit_message" && \
    git push --force-with-lease
}

dfmod() {
  if [ $# -lt 1 ]; then
    echo "Usage: dfmod \"Your commit message\""
    return 1
  fi
  
  message="$1"
  
  # Get list of modified files from git status
  modified_files=$(dotfiles status --porcelain | grep '^ M' | cut -c4-)
  
  if [ -z "$modified_files" ]; then
    echo "No modified files found."
    return 1
  fi
  
  # Add all modified files
  echo "$modified_files" | while read -r file; do
    dotfiles add "$file"
  done
  
  dotfiles commit -m "$message"
  dotfiles push
  echo "Modified files committed and pushed to remote."
}

clean_monorepo() {
  echo "üßπ Cleaning monorepo..."
  
  # Remove all node_modules directories
  echo "üì¶ Removing node_modules directories..."
  find . -name "node_modules" -type d -prune -exec rm -rf "{}" + || echo "‚ö†Ô∏è Error removing node_modules"
  
  # Remove all pnpm-lock.yaml files
  echo "üîí Removing pnpm-lock.yaml files..."
  find . -name "pnpm-lock.yaml" -type f -exec rm -f {} \; || echo "‚ö†Ô∏è Error removing pnpm-lock.yaml files"
  
  # Remove .pnpm-store directories (if using local store)
  echo "üè™ Removing .pnpm-store directories..."
  find . -name ".pnpm-store" -type d -prune -exec rm -rf "{}" + || echo "‚ö†Ô∏è Error removing .pnpm-store"
  
  # Remove package.json backup files
  echo "üóÑÔ∏è Removing package backup files..."
  find . -name "package.json.orig" -o -name "package.json.bak" -type f -exec rm -f {} \; || echo "‚ö†Ô∏è Error removing backup files"
  
  # Clean dist/build directories
  echo "üèóÔ∏è Removing dist/build directories..."
  find . -name "dist" -o -name "build" -type d -prune -exec rm -rf "{}" + || echo "‚ö†Ô∏è Error removing dist/build"
  
  # Clear pnpm cache
  echo "üßΩ Clearing pnpm store cache..."
  pnpm store prune || echo "‚ö†Ô∏è Error clearing pnpm cache"
  
  echo "‚ú® Cleanup complete!"
}

tm(){
    if [ -n "$1" ]; then
        TERM=tmux-256color tmux -u attach -t "$1" 2>/dev/null || TERM=tmux-256color tmux -u new -s "$1"
    else
        TERM=tmux-256color tmux -u attach || TERM=tmux-256color tmux -u new -s main
    fi
}

#*
## Name: tswap
## Desc: Create new tmux session and switch to it from within current session
## Inputs: session_name
## Usage: tswap newsession
tswap() {
    if [ -z "$1" ]; then
        echo "Usage: tswap <session_name>"
        return 1
    fi
    
    tmux new-session -d -s "$1" \; switch-client -t "$1"
}
#*

#*
## Name: tmrn
## Desc: Rename current tmux session
## Inputs: new_name - The new name for the current tmux session
## Usage: tmrn mynewname
tmrn() {
    if [ -z "$1" ]; then
        echo "Usage: tmrn <new_name>"
        return 1
    fi
    
    # Check if we're in a tmux session
    if [ -z "$TMUX" ]; then
        echo "Error: Not in a tmux session"
        return 1
    fi
    
    tmux rename-session "$1"
    echo "Session renamed to: $1"
}
#*

#*
## Name: sso
## Desc: AWS SSO login with optional remote cache sync
## Inputs: [optional] hostname to sync SSO cache to
## Usage: sso (local login only) or sso myserver (login and sync to remote)
sso() {
    if [ -z "$1" ]; then
        # No argument: just do normal SSO login
        command aws sso login --sso-session=theres-time-now
    else
        # Argument provided: SSO login then sync cache to remote server
        echo "üîê Logging into AWS SSO..."
        command aws sso login --sso-session=theres-time-now
        
        if [ $? -eq 0 ]; then
            echo "üì¶ Syncing SSO cache to $1..."
            
            # Create the .aws/sso/cache directory on remote if it doesn't exist
            ssh "$1" "mkdir -p ~/.aws/sso/cache"
            
            if [ $? -ne 0 ]; then
                echo "‚ùå Failed to create directory on $1"
                return 1
            fi
            
            # Copy the SSO cache files to the remote server
            for cache_file in ~/.aws/sso/cache/*.json; do
                if [ -f "$cache_file" ]; then
                    scp "$cache_file" "$1":~/.aws/sso/cache/
                fi
            done
            
            if [ $? -eq 0 ]; then
                echo "‚úÖ SSO cache synced to $1"
                
                # Also copy AWS config if it doesn't exist
                ssh "$1" "test -f ~/.aws/config"
                if [ $? -ne 0 ]; then
                    echo "üìù Copying AWS config to $1..."
                    scp ~/.aws/config "$1":~/.aws/
                fi
            else
                echo "‚ùå Failed to sync SSO cache to $1"
                return 1
            fi
        else
            echo "‚ùå SSO login failed"
            return 1
        fi
    fi
}
#*

#*
## Name: dfs
## Desc: Show dotfiles status for tracked files only
## Inputs: None
## Usage: dfs
dfs() {
    echo "üîç Dotfiles Status"
    echo "==================="
    
    # Show status of tracked files only
    local status_output=$(dotfiles status --short 2>/dev/null)
    
    if [[ -z "$status_output" ]]; then
        echo "‚úÖ All tracked dotfiles are up to date!"
    else
        echo -e "\nüìã Changed files:"
        echo "$status_output"
        
        # Count changes
        local modified_count=$(echo "$status_output" | grep -c '^ M' || true)
        local staged_count=$(echo "$status_output" | grep -c '^M' || true)
        local untracked_count=$(echo "$status_output" | grep -c '^??' || true)
        
        echo -e "\nüìä Summary:"
        [[ $modified_count -gt 0 ]] && echo "  ‚Ä¢ Modified: $modified_count files"
        [[ $staged_count -gt 0 ]] && echo "  ‚Ä¢ Staged: $staged_count files"
        [[ $untracked_count -gt 0 ]] && echo "  ‚Ä¢ Untracked: $untracked_count files"
    fi
    
    # Show last commit info
    echo -e "\nüìù Last commit:"
    dotfiles log -1 --oneline
}
#*

#*
## Name: start-play-mcp
## Desc: Start Playwright MCP server with HTTP transport on port 8931
## Usage: start-play-mcp
start-play-mcp() {
    local port=8931
    local mcp_command="bunx @playwright/mcp@latest --extension --port $port"
    
    # Check if something is already listening on the port
    if lsof -i :$port > /dev/null 2>&1; then
        # Check if it's our MCP server
        if ps aux | grep -q "[p]laywright/mcp.*--port $port"; then
            echo "‚úÖ Playwright MCP server is already running on port $port"
            echo "   URL: http://localhost:$port/mcp"
            return 0
        else
            echo "‚ö†Ô∏è  Port $port is in use by another process. Killing it..."
            # Kill whatever is using the port
            lsof -ti :$port | xargs kill -9 2>/dev/null
            sleep 1
        fi
    fi
    
    echo "üöÄ Starting Playwright MCP server on port $port..."
    echo "   Command: $mcp_command"
    
    # Start the server in background
    eval "$mcp_command" > /tmp/playwright-mcp.log 2>&1 &
    local pid=$!
    
    # Wait a moment for server to start
    sleep 3
    
    # Verify it started successfully
    if lsof -i :$port > /dev/null 2>&1; then
        echo "‚úÖ Playwright MCP server started successfully!"
        echo "   PID: $pid"
        echo "   URL: http://localhost:$port/mcp"
        echo ""
        echo "üìù Add this to your Claude config:"
        echo '   {
     "mcpServers": {
       "playwright": {
         "url": "http://localhost:'$port'/mcp"
       }
     }
   }'
    else
        echo "‚ùå Failed to start Playwright MCP server"
        echo "   Check /tmp/playwright-mcp.log for details"
        return 1
    fi
}
#*

#*
## Name: mcp-add
## Desc: Add MCP server from JSON configuration commonly found on GitHub
## Inputs: name - MCP server name
##         command - The command to run (e.g., "npx")
##         args - The arguments array (can be pasted directly from JSON)
## Usage: mcp-add playwright-extension npx '["@playwright/mcp@latest", "--extension"]'
##        mcp-add playwright-extension npx "@playwright/mcp@latest --extension"
mcp-add() {
    if [ $# -lt 3 ]; then
        echo "Usage: mcp-add <name> <command> <args>"
        echo ""
        echo "Examples:"
        echo '  mcp-add playwright-extension npx ["@playwright/mcp@latest", "--extension"]'
        echo '  mcp-add my-server node ["/path/to/server.js", "--flag"]'
        echo '  mcp-add simple-server npx "@simple/mcp@latest --verbose"'
        echo ""
        echo "You can paste the args array directly from GitHub JSON!"
        return 1
    fi
    
    local name="$1"
    local command="$2"
    shift 2
    local args_input="$*"
    
    # Check if args_input looks like a JSON array
    if [[ "$args_input" =~ ^\[.*\]$ ]]; then
        # Parse JSON array: remove brackets, quotes, commas, and extra whitespace
        local args=$(echo "$args_input" | \
            sed 's/^\[//; s/\]$//; s/,/ /g' | \
            sed 's/"//g' | \
            sed "s/'//g" | \
            sed 's/^[[:space:]]*//; s/[[:space:]]*$//' | \
            sed 's/[[:space:]]\+/ /g')
    else
        # Use as-is if not JSON array format
        local args="$args_input"
    fi
    
    echo "üîß Adding MCP server: $name"
    echo "   Command: $command"
    echo "   Args: $args"
    echo ""
    
    # Build the claude mcp add command
    # All GitHub JSON configs use stdio transport by default
    local full_command="claude mcp add $name -- $command $args"
    
    echo "üìù Running: $full_command"
    eval "$full_command"
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Successfully added MCP server: $name"
        echo ""
        echo "üìå Note: Most MCP servers from GitHub use stdio transport (default)"
        echo "   If you need SSE transport, use: claude mcp add-sse"
    else
        echo "‚ùå Failed to add MCP server"
        return 1
    fi
}
#*
## Name: ssh-kill
## Desc: Kill SSH master connection and optionally kill processes on a port
## Inputs: hostname - The SSH host to kill the connection for
##         port (optional) - Kill all processes using this port
## Usage: ssh-kill freefall
##        ssh-kill freefall 1337
ssh-kill() {
    if [ -z "$1" ]; then
        echo "Usage: ssh-kill <hostname> [port]"
        return 1
    fi
    
    local hostname="$1"
    local port="$2"
    
    # If port is specified, kill all processes using that port
    if [ -n "$port" ]; then
        echo "üîç Killing processes using port $port..."
        # Find and kill processes listening on the specified port
        local pids=$(lsof -iTCP:$port -sTCP:LISTEN -t 2>/dev/null)
        if [ -n "$pids" ]; then
            echo "$pids" | xargs kill -9 2>/dev/null
            echo "‚úÖ Killed processes on port $port"
        else
            echo "‚ö†Ô∏è  No processes found on port $port"
        fi
    fi
    
    # Try to exit the master connection gracefully
    ssh -O exit "$hostname" 2>/dev/null && echo "‚úÖ Killed SSH master for $hostname" || echo "‚ö†Ô∏è  No active master for $hostname"
    
    # Remove any stale control sockets for this host
    local socket_pattern=$(echo "$hostname" | sed 's/[^a-zA-Z0-9]/_/g')
    rm -f ~/.ssh/cm/*"$socket_pattern"* 2>/dev/null
    rm -f ~/.ssh/cm/*$(ssh -G "$hostname" 2>/dev/null | grep "^controlpath" | cut -d' ' -f2 | xargs basename 2>/dev/null)* 2>/dev/null
}
#*

#*
## Name: ssh-reconnect
## Desc: Kill SSH master connection and immediately reconnect
## Inputs: hostname - The SSH host to reconnect to
## Usage: ssh-reconnect freefall
ssh-reconnect() {
    if [ -z "$1" ]; then
        echo "Usage: ssh-reconnect <hostname>"
        return 1
    fi
    
    ssh-kill "$1"
    echo "üîÑ Reconnecting to $1..."
    ssh "$1"
}
#*

#*
## Name: ssh-forward
## Desc: Ensure SSH port forwarding is active for a host
## Inputs: hostname - The SSH host to establish forwarding for
## Usage: ssh-forward freefall
ssh-forward() {
    if [ -z "$1" ]; then
        echo "Usage: ssh-forward <hostname>"
        return 1
    fi
    
    # Check if master exists
    if ssh -O check "$1" 2>/dev/null; then
        echo "‚ö†Ô∏è  Master exists for $1, killing and reconnecting with forwarding..."
        ssh-kill "$1"
    fi
    
    # Start fresh connection with forwarding in background
    ssh -N -f "$1"
    echo "‚úÖ Port forwarding established for $1"
}
#*

#*
## Name: tk
## Desc: Kill tmux session and remove it from resurrect saved state
## Inputs: session_name - The name of the tmux session to kill permanently
## Usage: tk main
tk() {
    if [ -z "$1" ]; then
        echo "Usage: tk <session_name>"
        return 1
    fi
    
    # Kill the session
    tmux kill-session -t "$1" 2>/dev/null && echo "‚úÖ Killed session: $1" || echo "‚ö†Ô∏è Session not found: $1"
    
    # Remove from tmux-resurrect saved state
    local resurrect_dir="$HOME/.local/share/tmux/resurrect"
    if [ -d "$resurrect_dir" ]; then
        # Remove session from the last saved state
        local last_file=$(ls -t "$resurrect_dir"/tmux_resurrect_*.txt 2>/dev/null | head -1)
        if [ -f "$last_file" ]; then
            # Create backup
            cp "$last_file" "${last_file}.bak"
            # Remove lines related to this session
            grep -v "^pane[[:space:]]$1" "$last_file" | \
            grep -v "^window[[:space:]]$1" | \
            grep -v "^state[[:space:]]$1" > "${last_file}.tmp"
            mv "${last_file}.tmp" "$last_file"
            echo "‚úÖ Removed $1 from resurrect saved state"
        fi
    fi
}
#*

#*
## Name: start-rolling
## Desc: Start Rolling Bones development environment with Rails server and Vite in tmux session
## Inputs: None
## Usage: start-rolling
start-rolling() {
    # Change to the Rails directory
    builtin cd ~/Git/RollingBones/rolling_bones_rails || {
        echo "‚ùå Cannot find Rolling Bones Rails directory"
        return 1
    }
    
    # Check if we're already in a tmux session
    if [ -n "$TMUX" ]; then
        # Get current session name
        current_session=$(tmux display-message -p '#S')
        
        # Inside tmux - check if 'main' session exists
        if tmux has-session -t main 2>/dev/null; then
            if [ "$current_session" = "main" ]; then
                echo "‚úÖ Already in 'main' session!"
                
                # Check if both panes exist and have the right processes
                pane_count=$(tmux list-panes | wc -l | tr -d ' ')
                if [ "$pane_count" -lt 2 ]; then
                    echo "üîß Setting up Rails server and Vite in split panes..."
                    
                    # Kill anything on port 3000 first and start Rails server in current pane
                    tmux send-keys 'lsof -ti:3000 | xargs kill -9 2>/dev/null || true' C-m
                    sleep 0.5
                    tmux send-keys 'bundle exec rails s' C-m
                    
                    # Split and start Vite
                    tmux split-window -h -c ~/Git/RollingBones/rolling_bones_rails 'bin/vite dev'
                    
                    # Return focus to first pane
                    tmux select-pane -L
                else
                    echo "üìç Both panes already exist. Use them to start Rails and Vite manually if needed."
                fi
            else
                echo "üîÑ Switching to existing 'main' session..."
                tmux switch-client -t main
            fi
        else
            echo "üöÄ Creating new 'main' session and switching to it..."
            
            # Kill anything on port 3000 first
            lsof -ti:3000 | xargs kill -9 2>/dev/null || true
            
            # Create new session in background with Rails server
            tmux new-session -d -s main -c ~/Git/RollingBones/rolling_bones_rails 'bundle exec rails s'
            
            # Split vertically and start Vite
            tmux split-window -h -t main -c ~/Git/RollingBones/rolling_bones_rails 'bin/vite dev'
            
            # Return focus to first pane
            tmux select-pane -t main:1.0
            
            # Switch to the new session
            tmux switch-client -t main
        fi
    else
        # Not in tmux - attach or create normally
        if tmux has-session -t main 2>/dev/null; then
            echo "üîó Attaching to existing 'main' tmux session..."
            tmux attach-session -t main
        else
            echo "üöÄ Creating new 'main' tmux session with Rails server and Vite..."
            
            # Kill anything on port 3000 first
            lsof -ti:3000 | xargs kill -9 2>/dev/null || true
            
            # Create new tmux session with Rails server
            tmux new-session -d -s main -c ~/Git/RollingBones/rolling_bones_rails 'bundle exec rails s'
            
            # Split vertically and start Vite
            tmux split-window -h -t main -c ~/Git/RollingBones/rolling_bones_rails 'bin/vite dev'
            
            # Return focus to first pane
            tmux select-pane -t main:1.0
            
            # Attach to the session
            tmux attach-session -t main
        fi
    fi
}
#*

#*
## Name: gstats
## Desc: Display comprehensive git statistics for the current repository
## Inputs: None
## Usage: gstats
gstats() {
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "‚ùå Not in a git repository"
        return 1
    fi
    
    local user_name=$(git config user.name)
    local repo_name=$(basename -s .git $(git config --get remote.origin.url))
    
    echo "üìä Git Statistics for: $repo_name"
    echo "================================="
    echo ""
    
    echo "üë§ YOUR PERSONAL STATS:"
    echo "-----------------------"
    
    # Your total lines
    local your_stats=$(git log --author="$user_name" --pretty=tformat: --numstat | awk '{add += $1; subs += $2; loc += $1 - $2} END {printf "Added: %s, Removed: %s, Net: %s", add, subs, loc}')
    echo "  üìù All Time Lines: $your_stats"
    
    # Your commit count
    local your_commits=$(git log --author="$user_name" --oneline | wc -l | tr -d ' ')
    echo "  üî¢ Total Commits: $your_commits"
    
    # Your recent activity (last month)
    local recent_stats=$(git log --author="$user_name" --pretty=tformat: --numstat --since="1 month ago" | awk '{add += $1; subs += $2; loc += $1 - $2} END {printf "Added: %s, Removed: %s, Net: %s", add, subs, loc}')
    echo "  üìÖ Last Month: $recent_stats"
    
    # Your recent commits (last month)
    local recent_commits=$(git log --author="$user_name" --oneline --since="1 month ago" | wc -l | tr -d ' ')
    echo "  üìÖ Last Month Commits: $recent_commits"
    
    echo ""
    echo "üìä FULL REPOSITORY STATS:"
    echo "------------------------"
    
    # Total repository stats
    local total_commits=$(git rev-list --all --count)
    echo "  üî¢ Total Repository Commits: $total_commits"
    
    # Repository age
    local first_commit=$(git log --reverse --pretty=format:"%ad" --date=short | head -1)
    local last_commit=$(git log -1 --pretty=format:"%ad" --date=short)
    echo "  üìÖ Repository Age: $first_commit to $last_commit"
    
    # Active contributors (with commits)
    local contributor_count=$(git log --all --pretty=format:"%an" | sort | uniq | wc -l | tr -d ' ')
    echo "  üë• Active Contributors: $contributor_count"
    
    echo ""
    echo "üèÜ Top Contributors (by commits):"
    echo "---------------------------------"
    
    # All contributors by commit count
    git log --all --pretty=format:"%an" | sort | uniq -c | sort -nr | head -10 | while read count author; do
        if [ "$author" = "$user_name" ]; then
            echo "  üåü $count $author (YOU)"
        else
            echo "     $count $author"
        fi
    done
    
    echo ""
    echo "üìà Recent Activity (last 10 commits):"
    echo "------------------------------------"
    git log --oneline --date=short --pretty=format:"%C(yellow)%h%C(reset) %C(blue)%ad%C(reset) %C(green)%an%C(reset) %s" -10
}
#*
